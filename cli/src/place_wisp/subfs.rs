// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: place.wisp.subfs
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Directory<'a> {
    #[serde(borrow)]
    pub entries: Vec<crate::place_wisp::subfs::Entry<'a>>,
    #[serde(borrow)]
    pub r#type: jacquard_common::CowStr<'a>,
}

pub mod directory_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Type;
        type Entries;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Type = Unset;
        type Entries = Unset;
    }
    ///State transition - sets the `type` field to Set
    pub struct SetType<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetType<S> {}
    impl<S: State> State for SetType<S> {
        type Type = Set<members::r#type>;
        type Entries = S::Entries;
    }
    ///State transition - sets the `entries` field to Set
    pub struct SetEntries<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetEntries<S> {}
    impl<S: State> State for SetEntries<S> {
        type Type = S::Type;
        type Entries = Set<members::entries>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `type` field
        pub struct r#type(());
        ///Marker type for the `entries` field
        pub struct entries(());
    }
}

/// Builder for constructing an instance of this type
pub struct DirectoryBuilder<'a, S: directory_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<Vec<crate::place_wisp::subfs::Entry<'a>>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Directory<'a> {
    /// Create a new builder for this type
    pub fn new() -> DirectoryBuilder<'a, directory_state::Empty> {
        DirectoryBuilder::new()
    }
}

impl<'a> DirectoryBuilder<'a, directory_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        DirectoryBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DirectoryBuilder<'a, S>
where
    S: directory_state::State,
    S::Entries: directory_state::IsUnset,
{
    /// Set the `entries` field (required)
    pub fn entries(
        mut self,
        value: impl Into<Vec<crate::place_wisp::subfs::Entry<'a>>>,
    ) -> DirectoryBuilder<'a, directory_state::SetEntries<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        DirectoryBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DirectoryBuilder<'a, S>
where
    S: directory_state::State,
    S::Type: directory_state::IsUnset,
{
    /// Set the `type` field (required)
    pub fn r#type(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> DirectoryBuilder<'a, directory_state::SetType<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        DirectoryBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DirectoryBuilder<'a, S>
where
    S: directory_state::State,
    S::Type: directory_state::IsSet,
    S::Entries: directory_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Directory<'a> {
        Directory {
            entries: self.__unsafe_private_named.0.unwrap(),
            r#type: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Directory<'a> {
        Directory {
            entries: self.__unsafe_private_named.0.unwrap(),
            r#type: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

fn lexicon_doc_place_wisp_subfs() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
    ::jacquard_lexicon::lexicon::LexiconDoc {
        lexicon: ::jacquard_lexicon::lexicon::Lexicon::Lexicon1,
        id: ::jacquard_common::CowStr::new_static("place.wisp.subfs"),
        revision: None,
        description: None,
        defs: {
            let mut map = ::std::collections::BTreeMap::new();
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("directory"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("type"),
                            ::jacquard_common::smol_str::SmolStr::new_static("entries")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("entries"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: None,
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static("#entry"),
                                }),
                                min_length: None,
                                max_length: Some(500usize),
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("type"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("entry"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("name"),
                            ::jacquard_common::smol_str::SmolStr::new_static("node")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("name"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: Some(255usize),
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("node"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                description: None,
                                refs: vec![
                                    ::jacquard_common::CowStr::new_static("#file"),
                                    ::jacquard_common::CowStr::new_static("#directory"),
                                    ::jacquard_common::CowStr::new_static("#subfs")
                                ],
                                closed: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("file"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("type"),
                            ::jacquard_common::smol_str::SmolStr::new_static("blob")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("base64"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("blob"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Blob(::jacquard_lexicon::lexicon::LexBlob {
                                description: None,
                                accept: None,
                                max_size: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("encoding"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Content encoding (e.g., gzip for compressed files)",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("mimeType"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Original MIME type before compression",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("type"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("main"),
                ::jacquard_lexicon::lexicon::LexUserType::Record(::jacquard_lexicon::lexicon::LexRecord {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Virtual filesystem subtree referenced by place.wisp.fs records. When a subfs entry is expanded, its root entries are merged (flattened) into the parent directory, allowing large directories to be split across multiple records while maintaining a flat structure.",
                        ),
                    ),
                    key: None,
                    record: ::jacquard_lexicon::lexicon::LexRecordRecord::Object(::jacquard_lexicon::lexicon::LexObject {
                        description: None,
                        required: Some(
                            vec![
                                ::jacquard_common::smol_str::SmolStr::new_static("root"),
                                ::jacquard_common::smol_str::SmolStr::new_static("createdAt")
                            ],
                        ),
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "createdAt",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                    description: None,
                                    format: Some(
                                        ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                    ),
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "fileCount",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                    description: None,
                                    default: None,
                                    minimum: Some(0i64),
                                    maximum: Some(1000i64),
                                    r#enum: None,
                                    r#const: None,
                                }),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("root"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static("#directory"),
                                }),
                            );
                            map
                        },
                    }),
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("subfs"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: None,
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("type"),
                            ::jacquard_common::smol_str::SmolStr::new_static("subject")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("subject"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "AT-URI pointing to another place.wisp.subfs record for nested subtrees. When expanded, the referenced record's root entries are merged (flattened) into the parent directory, allowing recursive splitting of large directory structures.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::AtUri,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("type"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: None,
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map
        },
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Directory<'a> {
    fn nsid() -> &'static str {
        "place.wisp.subfs"
    }
    fn def_name() -> &'static str {
        "directory"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_place_wisp_subfs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        {
            let value = &self.entries;
            #[allow(unused_comparisons)]
            if value.len() > 500usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "entries",
                    ),
                    max: 500usize,
                    actual: value.len(),
                });
            }
        }
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Entry<'a> {
    #[serde(borrow)]
    pub name: jacquard_common::CowStr<'a>,
    #[serde(borrow)]
    pub node: EntryNode<'a>,
}

pub mod entry_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Name;
        type Node;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Name = Unset;
        type Node = Unset;
    }
    ///State transition - sets the `name` field to Set
    pub struct SetName<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetName<S> {}
    impl<S: State> State for SetName<S> {
        type Name = Set<members::name>;
        type Node = S::Node;
    }
    ///State transition - sets the `node` field to Set
    pub struct SetNode<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetNode<S> {}
    impl<S: State> State for SetNode<S> {
        type Name = S::Name;
        type Node = Set<members::node>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `name` field
        pub struct name(());
        ///Marker type for the `node` field
        pub struct node(());
    }
}

/// Builder for constructing an instance of this type
pub struct EntryBuilder<'a, S: entry_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<EntryNode<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Entry<'a> {
    /// Create a new builder for this type
    pub fn new() -> EntryBuilder<'a, entry_state::Empty> {
        EntryBuilder::new()
    }
}

impl<'a> EntryBuilder<'a, entry_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        EntryBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> EntryBuilder<'a, S>
where
    S: entry_state::State,
    S::Name: entry_state::IsUnset,
{
    /// Set the `name` field (required)
    pub fn name(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> EntryBuilder<'a, entry_state::SetName<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        EntryBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> EntryBuilder<'a, S>
where
    S: entry_state::State,
    S::Node: entry_state::IsUnset,
{
    /// Set the `node` field (required)
    pub fn node(
        mut self,
        value: impl Into<EntryNode<'a>>,
    ) -> EntryBuilder<'a, entry_state::SetNode<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        EntryBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> EntryBuilder<'a, S>
where
    S: entry_state::State,
    S::Name: entry_state::IsSet,
    S::Node: entry_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Entry<'a> {
        Entry {
            name: self.__unsafe_private_named.0.unwrap(),
            node: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Entry<'a> {
        Entry {
            name: self.__unsafe_private_named.0.unwrap(),
            node: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum EntryNode<'a> {
    #[serde(rename = "place.wisp.subfs#file")]
    File(Box<crate::place_wisp::subfs::File<'a>>),
    #[serde(rename = "place.wisp.subfs#directory")]
    Directory(Box<crate::place_wisp::subfs::Directory<'a>>),
    #[serde(rename = "place.wisp.subfs#subfs")]
    Subfs(Box<crate::place_wisp::subfs::Subfs<'a>>),
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Entry<'a> {
    fn nsid() -> &'static str {
        "place.wisp.subfs"
    }
    fn def_name() -> &'static str {
        "entry"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_place_wisp_subfs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        {
            let value = &self.name;
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 255usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "name",
                    ),
                    max: 255usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct File<'a> {
    /// True if blob content is base64-encoded (used to bypass PDS content sniffing)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base64: Option<bool>,
    /// Content blob ref
    #[serde(borrow)]
    pub blob: jacquard_common::types::blob::BlobRef<'a>,
    /// Content encoding (e.g., gzip for compressed files)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub encoding: Option<jacquard_common::CowStr<'a>>,
    /// Original MIME type before compression
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub mime_type: Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub r#type: jacquard_common::CowStr<'a>,
}

pub mod file_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Type;
        type Blob;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Type = Unset;
        type Blob = Unset;
    }
    ///State transition - sets the `type` field to Set
    pub struct SetType<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetType<S> {}
    impl<S: State> State for SetType<S> {
        type Type = Set<members::r#type>;
        type Blob = S::Blob;
    }
    ///State transition - sets the `blob` field to Set
    pub struct SetBlob<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetBlob<S> {}
    impl<S: State> State for SetBlob<S> {
        type Type = S::Type;
        type Blob = Set<members::blob>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `type` field
        pub struct r#type(());
        ///Marker type for the `blob` field
        pub struct blob(());
    }
}

/// Builder for constructing an instance of this type
pub struct FileBuilder<'a, S: file_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<bool>,
        ::core::option::Option<jacquard_common::types::blob::BlobRef<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> File<'a> {
    /// Create a new builder for this type
    pub fn new() -> FileBuilder<'a, file_state::Empty> {
        FileBuilder::new()
    }
}

impl<'a> FileBuilder<'a, file_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        FileBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: file_state::State> FileBuilder<'a, S> {
    /// Set the `base64` field (optional)
    pub fn base64(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `base64` field to an Option value (optional)
    pub fn maybe_base64(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S> FileBuilder<'a, S>
where
    S: file_state::State,
    S::Blob: file_state::IsUnset,
{
    /// Set the `blob` field (required)
    pub fn blob(
        mut self,
        value: impl Into<jacquard_common::types::blob::BlobRef<'a>>,
    ) -> FileBuilder<'a, file_state::SetBlob<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        FileBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: file_state::State> FileBuilder<'a, S> {
    /// Set the `encoding` field (optional)
    pub fn encoding(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `encoding` field to an Option value (optional)
    pub fn maybe_encoding(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S: file_state::State> FileBuilder<'a, S> {
    /// Set the `mimeType` field (optional)
    pub fn mime_type(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value.into();
        self
    }
    /// Set the `mimeType` field to an Option value (optional)
    pub fn maybe_mime_type(
        mut self,
        value: Option<jacquard_common::CowStr<'a>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value;
        self
    }
}

impl<'a, S> FileBuilder<'a, S>
where
    S: file_state::State,
    S::Type: file_state::IsUnset,
{
    /// Set the `type` field (required)
    pub fn r#type(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> FileBuilder<'a, file_state::SetType<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        FileBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> FileBuilder<'a, S>
where
    S: file_state::State,
    S::Type: file_state::IsSet,
    S::Blob: file_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> File<'a> {
        File {
            base64: self.__unsafe_private_named.0,
            blob: self.__unsafe_private_named.1.unwrap(),
            encoding: self.__unsafe_private_named.2,
            mime_type: self.__unsafe_private_named.3,
            r#type: self.__unsafe_private_named.4.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> File<'a> {
        File {
            base64: self.__unsafe_private_named.0,
            blob: self.__unsafe_private_named.1.unwrap(),
            encoding: self.__unsafe_private_named.2,
            mime_type: self.__unsafe_private_named.3,
            r#type: self.__unsafe_private_named.4.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for File<'a> {
    fn nsid() -> &'static str {
        "place.wisp.subfs"
    }
    fn def_name() -> &'static str {
        "file"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_place_wisp_subfs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Virtual filesystem subtree referenced by place.wisp.fs records. When a subfs entry is expanded, its root entries are merged (flattened) into the parent directory, allowing large directories to be split across multiple records while maintaining a flat structure.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct SubfsRecord<'a> {
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_count: Option<i64>,
    #[serde(borrow)]
    pub root: crate::place_wisp::subfs::Directory<'a>,
}

pub mod subfs_record_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Root;
        type CreatedAt;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Root = Unset;
        type CreatedAt = Unset;
    }
    ///State transition - sets the `root` field to Set
    pub struct SetRoot<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRoot<S> {}
    impl<S: State> State for SetRoot<S> {
        type Root = Set<members::root>;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type Root = S::Root;
        type CreatedAt = Set<members::created_at>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `root` field
        pub struct root(());
        ///Marker type for the `created_at` field
        pub struct created_at(());
    }
}

/// Builder for constructing an instance of this type
pub struct SubfsRecordBuilder<'a, S: subfs_record_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<i64>,
        ::core::option::Option<crate::place_wisp::subfs::Directory<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> SubfsRecord<'a> {
    /// Create a new builder for this type
    pub fn new() -> SubfsRecordBuilder<'a, subfs_record_state::Empty> {
        SubfsRecordBuilder::new()
    }
}

impl<'a> SubfsRecordBuilder<'a, subfs_record_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        SubfsRecordBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubfsRecordBuilder<'a, S>
where
    S: subfs_record_state::State,
    S::CreatedAt: subfs_record_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> SubfsRecordBuilder<'a, subfs_record_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        SubfsRecordBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: subfs_record_state::State> SubfsRecordBuilder<'a, S> {
    /// Set the `fileCount` field (optional)
    pub fn file_count(mut self, value: impl Into<Option<i64>>) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `fileCount` field to an Option value (optional)
    pub fn maybe_file_count(mut self, value: Option<i64>) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S> SubfsRecordBuilder<'a, S>
where
    S: subfs_record_state::State,
    S::Root: subfs_record_state::IsUnset,
{
    /// Set the `root` field (required)
    pub fn root(
        mut self,
        value: impl Into<crate::place_wisp::subfs::Directory<'a>>,
    ) -> SubfsRecordBuilder<'a, subfs_record_state::SetRoot<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        SubfsRecordBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubfsRecordBuilder<'a, S>
where
    S: subfs_record_state::State,
    S::Root: subfs_record_state::IsSet,
    S::CreatedAt: subfs_record_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> SubfsRecord<'a> {
        SubfsRecord {
            created_at: self.__unsafe_private_named.0.unwrap(),
            file_count: self.__unsafe_private_named.1,
            root: self.__unsafe_private_named.2.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> SubfsRecord<'a> {
        SubfsRecord {
            created_at: self.__unsafe_private_named.0.unwrap(),
            file_count: self.__unsafe_private_named.1,
            root: self.__unsafe_private_named.2.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> SubfsRecord<'a> {
    pub fn uri(
        uri: impl Into<jacquard_common::CowStr<'a>>,
    ) -> Result<
        jacquard_common::types::uri::RecordUri<'a, SubfsRecordRecord>,
        jacquard_common::types::uri::UriError,
    > {
        jacquard_common::types::uri::RecordUri::try_from_uri(
            jacquard_common::types::string::AtUri::new_cow(uri.into())?,
        )
    }
}

/// Typed wrapper for GetRecord response with this collection's record type.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct SubfsRecordGetRecordOutput<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub cid: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub value: SubfsRecord<'a>,
}

impl From<SubfsRecordGetRecordOutput<'_>> for SubfsRecord<'_> {
    fn from(output: SubfsRecordGetRecordOutput<'_>) -> Self {
        use jacquard_common::IntoStatic;
        output.value.into_static()
    }
}

impl jacquard_common::types::collection::Collection for SubfsRecord<'_> {
    const NSID: &'static str = "place.wisp.subfs";
    type Record = SubfsRecordRecord;
}

/// Marker type for deserializing records from this collection.
#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct SubfsRecordRecord;
impl jacquard_common::xrpc::XrpcResp for SubfsRecordRecord {
    const NSID: &'static str = "place.wisp.subfs";
    const ENCODING: &'static str = "application/json";
    type Output<'de> = SubfsRecordGetRecordOutput<'de>;
    type Err<'de> = jacquard_common::types::collection::RecordError<'de>;
}

impl jacquard_common::types::collection::Collection for SubfsRecordRecord {
    const NSID: &'static str = "place.wisp.subfs";
    type Record = SubfsRecordRecord;
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for SubfsRecord<'a> {
    fn nsid() -> &'static str {
        "place.wisp.subfs"
    }
    fn def_name() -> &'static str {
        "main"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_place_wisp_subfs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.file_count {
            if *value > 1000i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Maximum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "file_count",
                    ),
                    max: 1000i64,
                    actual: *value,
                });
            }
        }
        if let Some(ref value) = self.file_count {
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "file_count",
                    ),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        Ok(())
    }
}

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Subfs<'a> {
    /// AT-URI pointing to another place.wisp.subfs record for nested subtrees. When expanded, the referenced record's root entries are merged (flattened) into the parent directory, allowing recursive splitting of large directory structures.
    #[serde(borrow)]
    pub subject: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub r#type: jacquard_common::CowStr<'a>,
}

pub mod subfs_state {

    pub use crate::builder_types::{Set, Unset, IsSet, IsUnset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Type;
        type Subject;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Type = Unset;
        type Subject = Unset;
    }
    ///State transition - sets the `type` field to Set
    pub struct SetType<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetType<S> {}
    impl<S: State> State for SetType<S> {
        type Type = Set<members::r#type>;
        type Subject = S::Subject;
    }
    ///State transition - sets the `subject` field to Set
    pub struct SetSubject<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSubject<S> {}
    impl<S: State> State for SetSubject<S> {
        type Type = S::Type;
        type Subject = Set<members::subject>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `type` field
        pub struct r#type(());
        ///Marker type for the `subject` field
        pub struct subject(());
    }
}

/// Builder for constructing an instance of this type
pub struct SubfsBuilder<'a, S: subfs_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::AtUri<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Subfs<'a> {
    /// Create a new builder for this type
    pub fn new() -> SubfsBuilder<'a, subfs_state::Empty> {
        SubfsBuilder::new()
    }
}

impl<'a> SubfsBuilder<'a, subfs_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        SubfsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubfsBuilder<'a, S>
where
    S: subfs_state::State,
    S::Subject: subfs_state::IsUnset,
{
    /// Set the `subject` field (required)
    pub fn subject(
        mut self,
        value: impl Into<jacquard_common::types::string::AtUri<'a>>,
    ) -> SubfsBuilder<'a, subfs_state::SetSubject<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        SubfsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubfsBuilder<'a, S>
where
    S: subfs_state::State,
    S::Type: subfs_state::IsUnset,
{
    /// Set the `type` field (required)
    pub fn r#type(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> SubfsBuilder<'a, subfs_state::SetType<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        SubfsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> SubfsBuilder<'a, S>
where
    S: subfs_state::State,
    S::Type: subfs_state::IsSet,
    S::Subject: subfs_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Subfs<'a> {
        Subfs {
            subject: self.__unsafe_private_named.0.unwrap(),
            r#type: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Subfs<'a> {
        Subfs {
            subject: self.__unsafe_private_named.0.unwrap(),
            r#type: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Subfs<'a> {
    fn nsid() -> &'static str {
        "place.wisp.subfs"
    }
    fn def_name() -> &'static str {
        "subfs"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_place_wisp_subfs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}